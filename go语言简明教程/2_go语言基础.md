# Go语言基础

## 常量

1. 常量声明和初始化赋值

- 常量使用关键字 `const` 声明
- Go 的常量定义可以限定常量类型，但不是必需的。如果定义常量时没有指定类型，那么该常量就是无类型常量，也叫字面常量。

```go
const limit = 512
const top uint16 = 1421
const Pi float64 = 3.1415926
const x,y int = 1,3 //多重赋值
```

2. 设置多个常量

 ```go
 const (
     Cyan = 0
     Black = 1
     White = 2
 )
 ```

3. 预定义常量：true/false/iota

`iota` 是一个可以被编译器修改的常量，在 `const` 关键字出现时被重置为 0，在下一个 `const` 出现之前，每出现一次 `iota`，其所代表的数字自动加 1。

```go
const (
    a = iota  //a == 0
    b = iota  //b ==1
    c = iota  //c == 2
)

const d = iota //d==0,因为const的出现，iota被重置为0
```



## 变量

1. 变量声明和初始化

- 使用关键字 `var` 对变量进行声明
- 使用 `:=` 来对变量直接进行初始化，Go 编译器会自动推导出该变量的类型，需要注意的是 `:=` 左侧的变量不能是已经被声明过的，否则会导致编译器错误。

```go
var a int
var b string
var c float64
var d [5] int  //数组
var e [] int   //数组切片
var f * int    //正确
var v1 int = 5 //正确
var v2 = 5     //正确，编译器自动推导出V2类型
v3 := 5        //正确，编译器自动推导出V3的类型
```

2. 多重赋值

```go
i := 2
j := 3
i, j = j, i  //交换i和j的值，此时i == 3，j == 2
```

## 数据类型

### 整型

Go 语言提供了 11 种整型，如下列表所示。

| 类型      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| `byte`    | 等同于 uint8                                                 |
| `int`     | 依赖于不同平台下的实现，可以是 int32 或者 int64              |
| `int8`    | [-128, 127]                                                  |
| `int16`   | [-32768, 32767]                                              |
| `int32`   | [-2147483648, 2147483647]                                    |
| `int64`   | [-9223372036854775808, 9223372036854775807]                  |
| `rune`    | 等同于 int32                                                 |
| `uint`    | 依赖于不同平台下的实现，可以是 uint32 或者 uint64            |
| `uint8`   | [0, 255]                                                     |
| `uint16`  | [0, 65535]                                                   |
| `uint32`  | [0, 4294967295]                                              |
| `uint64`  | [0, 18446744073709551615]                                    |
| `uintptr` | 一个可以恰好容纳指针值的无符号整型（对 32 位平台是 uint32, 对 64 位平台是 uint64） |

- `unsafe.Sizeof` 方法获取类型的字节长度

```go
package main

import (
	"fmt"
	"unsafe"
)

func main(){
	a := 12
	fmt.Println("length of a:", unsafe.Sizeof(a)) // 8

	var b int  = 12
	fmt.Println("length of a:", unsafe.Sizeof(b)) // 8

	var c int8  = 12
	fmt.Println("length of a:", unsafe.Sizeof(c)) // 1

	var d int16  = 12
	fmt.Println("length of a:", unsafe.Sizeof(d)) // 2

	var e int32  = 12
	fmt.Println("length of a:", unsafe.Sizeof(e)) // 4

	var f int64  = 12
	fmt.Println("length of a:", unsafe.Sizeof(f)) // 8
}
```

### 浮点型

Go 语言提供了两种浮点类型和两种复数类型，具体如下：

| 类型      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| float32   | ±3.402 823 466 385 288 598 117 041 834 845 169 254 40x1038 计算精度大概是小数点后 7 个十进制数 |
| float64   | ±1.797 693 134 862 315 708 145 274 237 317 043 567 981x1038 计算精度大概是小数点后 15 个十进制数 |
| complex32 | 复数，实部和虚部都是 float32                                 |
| complex64 | 复数，实部和虚部都是 float64                                 |

### 布尔类型

- Go 语言提供了内置的布尔值 `true` 和`false`
- 以通过 `!b` 的方式反转变量 `b` 的真假
- 布尔类型不能接受其他类型的赋值
- 不支持自动或强制的类型转换

```go
var a bool
a = true
b := (2 == 3) //b也会被推导为bool类型

//错误示范
var b bool
b = 1 //编译错误
b = bool(1) //编译错误
```

### 字符串类型

- Go 语言中的字符串是 [UTF-8](http://zh.wikipedia.org/wiki/UTF-8) 字符的一个序列（当字符为 ASCII 码时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。UTF-8 是被广泛使用的编码格式，是文本文件的标准编码，其它包括 XML 和 JSON 在内，也都使用该编码。由于该编码对占用字节长度的不定性，Go 中的字符串也可能根据需要占用 1 至 4 个字节，这与其它语言如 C++、Java 或者 Python 不同。Go 这样做的好处是不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。
- 使用双引号 (`"`) 或者反引号 (```) 来创建字符串
- 使用单引号 (`'`) 来创建单字符。在 Go 语言中，一个单一的字符可以用一个单一的 `rune` 来表示。这也是容易理解的，因为 Go 语言的字符串是 UTF-8 编码，其底层使用 4 个字节表示，也就是 32 bit。
- 双引号用来创建可解析的字符串字面量，所谓可解析的是指字符串中的一些符号可以被格式化为其他内容，如 `\n` 在在输出时候会被格式化成换行符，如果需要按照原始字符输出必须进行转义。
- 反引号创建的字符串原始是什么样，那输出还是什么，不需要进行任何转义。
- 在 Go 语言中，字符串支持切片操作，但是需要注意的是如果字符串都是由 ASCII 字符组成，那可以随便使用切片进行操作，但是如果字符串中包含其他非 ASCII 字符，直接使用切片获取想要的单个字符时需要十分小心，因为对字符串直接使用切片时是通过字节进行索引的，但是非 ASCII 字符在内存中可能不是由一个字节组成。如果想对字符串中字符依次访问，可以使用 `range` 操作符。另外获取字符串的长度可能有两种含义，一种是指获取字符串的字节长度，一种是指获取字符串的字符数量。

Go 语言中的部分转义字符如下表所示：

| 转义字符 | 含义                                |
| -------- | ----------------------------------- |
| `\\`     | 表示反斜线                          |
| `\'`     | 单引号                              |
| `\"`     | 双引号                              |
| `\n`     | 换行符                              |
| `\uhhhh` | 4 个 16 进制数字给定的 Unicode 字符 |

字符串支持以下操作：

| 语法             | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| `s += t`         | 将字符串 t 追加到 s 末尾                                     |
| `s + t`          | 将字符串 s 和 t 级联                                         |
| `s[n]`           | 从字符串 s 中索引位置为 n 处的原始字节                       |
| `s[n:m]`         | 从位置 n 到位置 `m-1` 处取得的字符（字节）串                 |
| `s[n:]`          | 从位置 n 到位置 `len(s)-1` 处取得的字符（字节）串            |
| `s[:m]`          | 从位置 0 到位置 `m-1` 处取得的字符（字节）串                 |
| `len(s)`         | 字符串 s 中的字节数                                          |
| `len([]rune(s))` | 字符串 s 中字符的个数，可以使用更快的方法 `utf8.RuneCountInString()` |
| `[]rune(s)`      | 将字符串 s 转换为一个 unicode 值组成的串                     |
| `string(chars)`  | chars 类型是 `[]rune` 或者 `[]int32`, 将之转换为字符串       |
| `[]byte(s)`      | 无副本的将字符串 s 转换为一个原始的字节的切片数组，不保证转换的字节是合法的 UTF-8 编码字节 |

编码-字符-字节

**不同编码里，字符和字节的对应关系不同**，与编码方式有关。

常见的编码字符与字节的对应关系如下：

**1. ASCII码**中，一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。

**2. UTF-8编码**中，一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。

**3. Unicode编码**中，一个英文等于两个字节，一个中文（含繁体）等于两个字节。
符号：英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占1个字节的大小，中文句号“。”占2个字节的大小。

**4. GBK编码**方式是中文占两个字节，英文占1个字节。

```go
package main

import (
	"fmt"
)
func main(){
	t0 := "\u6B22\u8FCE\u6765\u5230" // 欢迎来到
	t1 := "\u5B9E\u9A8C\u697C"       // 实验楼
	t2 := t0 + t1 // 欢迎来到实验楼

	// %-2d: 打印字符在t2中的位置,输出0-3-6...是因为按照字节来计算
	// %U: 打印unicode码值
	// %c: 打印每个字符的字面量
	// %X: 打印每个字符的十六进制值
	// %d: 打印每个字符对应字节长度
    for index, char := range t2 {
        fmt.Printf("%-2d    %U      '%c'    %X      %d\n",
            index, char, char, []byte(string(char)), len([]byte(string(char))))
	}
	// 0     U+6B22      '欢'    E6ACA2      3
	// 3     U+8FCE      '迎'    E8BF8E      3
	// 6     U+6765      '来'    E69DA5      3
	// 9     U+5230      '到'    E588B0      3
	// 12    U+5B9E      '实'    E5AE9E      3
	// 15    U+9A8C      '验'    E9AA8C      3
	// 18    U+697C      '楼'    E6A5BC      3
    fmt.Printf("length of t0: %d, t1: %d, t2: %d\n", len(t0), len(t1), len(t2)) // length of t0: 12, t1: 9, t2: 21
	
	// 使用切片访问了字符串 t2 的第 0-1 个字节，也就是前两个字节，其内容为 E6AC。
	// 字符 欢 其底层使用了三个字节表示，内容是 E6ACA2
	// 字符的切片是通过字节数来索引的
	fmt.Printf("content of t2[0:2] is: %X\n", t2[0:2]) // content of t2[0:2] is: E6AC

	str := "你好世界"
	str1 := str[0:3] 

	fmt.Println(str1) // 你
}
```

格式化字符串

| 格式化指令 | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| `%%`       | % 字面量                                                     |
| `%b`       | 一个二进制整数，将一个整数格式化为二进制的表达方式           |
| `%c`       | 一个 Unicode 的字符                                          |
| `%d`       | 十进制数值                                                   |
| `%o`       | 八进制数值                                                   |
| `%x`       | 小写的十六进制数值                                           |
| `%X`       | 大写的十六进制数值                                           |
| `%U`       | 一个 Unicode 表示法表示的整形码值，默认是 4 个数字字符       |
| `%s`       | 输出以原生的 UTF-8 字节表示的字符，如果 console 不支持 UTF-8 编码，则会输出乱码 |
| `%t`       | 以 true 或者 false 的方式输出布尔值                          |
| `%v`       | 使用默认格式输出值，或者使用类型的 String() 方法输出的自定义值，如果该方法存在的话 |
| %T         | 输出值的类型                                                 |
| %p         | 输出地址                                                     |

常用的格式化指令修饰符如下：

- `数字`：指定宽度，如果宽度不足，则用空白填充。比如`%8d`,输出宽度为8位，不足则左补零。

- `空白` 如果输出的数字为负，则在其前面加上一个减号 `-`。如果输出的是整数，则在前面加一个空格。使用 `%x` 或者 `%X` 格式化指令输出时，会在结果之间添加一个空格。例如 `fmt.Printf("% X", "实")` 输出 E5 AE 9E。
- `#` 
  - `%#o` 输出以 `0` 开始的八进制数据。
  - `%#x` 输出以 `0x` 开始的十六进制数据。
- `+` 让格式化指令在数值前面输出 `+` 号或者 `-` 号，为字符串输出 ASCII 字符（非 ASCII 字符会被转义），为结构体输出其字段名。
- `-` 让格式化指令将值向左对齐（默认值为像右对齐）。
- `0` 让格式指令以数字 0 而非空白进行填充。

```go
package main

import (
    "fmt"
)

func main() {
    text := "\u5B9E\u9A8C\u697C" // 实验楼的unicode编码
    fmt.Printf("bool output:\n%t\n%t\n\n", true, false) // true false
    fmt.Println("number output, origin value: 64")
    fmt.Printf("|%b|%8b|%-8b|%08b|% 8b|\n", 64, 64, 64, 64, 64) // |1000000| 1000000|1000000 |01000000| 1000000|
    fmt.Printf("|%x|%8x|%-8x|%08X|% 8X|\n\n", 64, 64, 64, 64, 64) // |40|      40|40      |00000040|      40|
    fmt.Println(`text output, origin value: \u5B9E\u9A8C\u697C`)
    fmt.Printf("content: %s\n", text) // 实验楼
    fmt.Printf("hex value: % X\nUnicode value: ", text) // E5 AE 9E E9 AA 8C E6 A5 BC
    for _, char := range text {
        fmt.Printf("%U ", char)
    } // U+5B9E U+9A8C U+697C
    fmt.Println()
    bytes := []byte(text)
    fmt.Printf("value of bytes: %s\n", bytes) // 实验楼
    fmt.Printf("hex value of bytes: % X\n", bytes) // E5 AE 9E E9 AA 8C E6 A5 BC
    fmt.Printf("origin value of bytes: %v\n", bytes) // [229 174 158 233 170 140 230 165 188]

}
```

### 字符类型

支持两个字符类型，一个是 `Byte`（实际上是 Unit8 的别名），代表 UTF-8 字符串的单个字节的值；另一个是 `rune`，代表单个 Unicode 字符。

### 数组

Go 语言的数组是一个定长的序列，其中的元素类型相同。多维数组可以简单地使用自身为数组的元素来创建。数组的元素使用操作符号 `[ ]` 来索引，索引从 `0` 开始，到 `len(array)-1` 结束。

创建数组

- `[length]Type`
- `[N]Type{value1, value2, ..., valueN}`
- `[...]Type{value1, value2, ..., valueN}`

使用了 `...`（省略符）操作符，Go 语言会为我们自动计算数组的长度。

在任何情况下，一个数组的长度都是固定的并且不可修改。

数组的长度可以使用 `len()` 函数获得。由于数组的长度是固定的，因此数组的长度和容量都是一样的，因此对于数组而言 `cap()` 和 `len()` 函数返回值都是一样的。

数组进行切片，其结果为切片，而非数组。

数组也可以使用 `range` 进行索引访问。

### 切片

数组是按值传递的（即是传递的副本），而切片是引用类型，传递切片的成本非常小，而且是不定长的。而且数组是定长的，而切片可以调整长度。

创建切片

- `make([ ]Type, length, capacity)`
- `make([ ]Type, length)`
- `[ ]Type{}`
- `[ ]Type{value1, value2, ..., valueN}`

内置函数 `make()` 用于创建切片、映射和通道。当用于创建一个切片时，它会创建一个隐藏的初始化为零值的数组，然后返回一个引用该隐藏数组的切片。该隐藏的数组与 Go 语言中的所有数组一样，都是固定长度。

如果使用第一种语法创建，那么其长度为切片的容量 `capacity`；

如果是第二种语法，那么其长度记为切片的长度 `length`。

一个切片的容量即为隐藏数组的长度，而其长度则为不超过该容量的任意值。

另外可以通过内置的函数 `append()` 来增加切片的容量。

```go
package main


import (
	"fmt"
)

func main(){
	a := [...]int{1,2,3,4,5,6,7,8}
	fmt.Printf("数组a:%v的长度是%d, 容量是%d.\n", a, len(a), cap(a)) // 数组a:[1 2 3 4 5 6 7]的长度是7, 容量是7.

	for _,value := range a{
		fmt.Printf("% d", value)
	} // 1 2 3 4 5 6 7

	fmt.Println()

	s1 := a[4:6]

	fmt.Printf("数组s1:%v的长度是%d, 容量是%d.\n", s1, len(s1), cap(s1)) // 数组s1:[4 5 6]的长度是3, 容量是4.

	for _,value := range s1{
		fmt.Printf("% d", value)
	} // 4 5 6

	fmt.Println()

	s1[0] = 456

	fmt.Printf("修改过数组s1:%v的长度是%d, 容量是%d.\n", s1, len(s1), cap(s1)) // 修改过数组s1:[456 5 6]的长度是3, 容量是4.

	for _,value := range s1{
		fmt.Printf("% d", value)
	} //  456 5 6

	fmt.Println()

	s2 := make([]int, 10, 20)
	s2[4] = 5
	fmt.Printf("数组s2:%v的长度是%d, 容量是%d.\n", s2, len(s2), cap(s2)) // 数组s2:[0 0 0 0 5 0 0 0 0 0]的长度是10, 容量是20.

	for _,value := range s2{
		fmt.Printf("% d", value)
	} //   0 0 0 0 5 0 0 0 0 0

	fmt.Println()
}
```

注意此处数组转为切片时扩容长度的变化，切片扩容有自己的规则，可以深入了解一下。

## 包

- Go 语言组织代码的方式是包，包是各种类型和函数的集合
- 在包中，如果标示符（类型名称，函数名称，方法名称）的首字母是大写，那这些标示符是可以被导出的，也就是说可以在包以外直接使用。
- 当我们使用 `import` 关键字导入包的时候，Go 语言会在 `$GOPATH` 和 `GOROOT` 目录中搜索包。
- 创建的自定义的包最好放在 `$GOPATH` 的 `src` 目录下，如果这个包只属于某个应用程序，可以直接放在应用程序源代码的子目录下，但如果我们希望这个包可以被其他的应用程序共享，那就应该放在 `$GOPATH` 的 `src` 目录下，每个包单独放在一个目录里，如果两个不同的包放在同一目录下，会出现名字冲突的编译错误。作为惯例，包的源代码应该放在一个同名的文件夹下面。同一个包可以有任意多的源文件，文件名的名字也没有任何规定。

